
  ? def moduleFromFile := <import:org.cubik.cle.module.moduleFromFile>
  # value: <moduleFromFile>

  ? def loadModule := <import:org.cubik.cle.module.loadModule>
  # value: <loadModule>
  
To use a module, you must acquire a module object, then load it. The result of loading is called a module instance.

XXX review terms 'load' and 'module instance'

  ? def testModule := moduleFromFile(<file:modules/test1/>); null
  
There will eventually be options relating to how changes in the filesystem affect the module.

  ? def instance := loadModule(testModule, [].asMap())
  # value: <moduleInstance>
  
  ? def scopeTester := instance["scopeTester"]
  # value: <scopeTester>
  
  ? [def r := scopeTester.getLoader(), r == instance]
  # value: [<moduleInstance>, true]
  XXX this will become false as soon as we implement internal names

  ? testModule["scopeTester.emaker"].getText().split("\n")[0]
  # value: "# First line of scopeTester.emaker"
  




development notes:

florbs
  filesystem rep: emakers, resources, and a metadata file (in E, or not?)
  metadata file records dependencies, and what names are imported from each
  resources are importable things; florb can extend file->object mapping?

To use a florb:
  makeFlorb(<file:///florbs/myFlorb/>) => florb, must have no dependencies
  makeFlorbLoader(file:///florbs/>)["myFlorb"] => florb, with dependencies loaded from same directory
  florb has a loader interface (get,optUnget), optional getRootObject when that makes sense, and possibly iteration


which is primary: files or objects?